[
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "src.typehints",
        "description": "src.typehints",
        "isExtraImport": true,
        "detail": "src.typehints",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "accumulate",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "accumulate",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "accumulate",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "inf",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "inf",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "Rational",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Rational",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Real",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Real",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappush",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappush",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappush",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "partition",
        "importPath": "algorithms.partition",
        "description": "algorithms.partition",
        "isExtraImport": true,
        "detail": "algorithms.partition",
        "documentation": {}
    },
    {
        "label": "partition",
        "importPath": "algorithms.partition",
        "description": "algorithms.partition",
        "isExtraImport": true,
        "detail": "algorithms.partition",
        "documentation": {}
    },
    {
        "label": "partition",
        "importPath": "algorithms.partition",
        "description": "algorithms.partition",
        "isExtraImport": true,
        "detail": "algorithms.partition",
        "documentation": {}
    },
    {
        "label": "partition",
        "importPath": "algorithms.partition",
        "description": "algorithms.partition",
        "isExtraImport": true,
        "detail": "algorithms.partition",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "Employee",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "Job",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "sort_employees_by_salary",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "Employee",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "Job",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "sort_employees_by_salary",
        "importPath": "employees",
        "description": "employees",
        "isExtraImport": true,
        "detail": "employees",
        "documentation": {}
    },
    {
        "label": "backpedal",
        "kind": 2,
        "importPath": ".gitbook.assets.backpedal (1)",
        "description": ".gitbook.assets.backpedal (1)",
        "peekOfCode": "def backpedal(goal: Node, parents: Mapping[Node, Optional[Node]]) -> list[Node]:\n    \"\"\"With a dict of parent->child, walk backwards from the goal as far as possible and return the path.\"\"\"\n    back_path = []\n    node = goal\n    while node is not None:\n        back_path.append(node)\n        node = parents[node]\n    return back_path[::-1]",
        "detail": ".gitbook.assets.backpedal (1)",
        "documentation": {}
    },
    {
        "label": "backpedal",
        "kind": 2,
        "importPath": ".gitbook.assets.backpedal",
        "description": ".gitbook.assets.backpedal",
        "peekOfCode": "def backpedal(goal: Node, parents: Mapping[Node, Optional[Node]]) -> list[Node]:\n    \"\"\"With a dict of parent->child, walk backwards from the goal as far as possible and return the path.\"\"\"\n    back_path = []\n    node = goal\n    while node is not None:\n        back_path.append(node)\n        node = parents[node]\n    return back_path[::-1]",
        "detail": ".gitbook.assets.backpedal",
        "documentation": {}
    },
    {
        "label": "bfs_paths_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_paths_dict (1)",
        "description": ".gitbook.assets.bfs_paths_dict (1)",
        "peekOfCode": "def bfs_paths_dict(graph: Mapping[Node, set[Node]], start: Node, goal: Node) -> Iterable[list[Node]]:\n    \"\"\"Find all the paths from start to goal using BFS on a dict.\"\"\"\n    to_visit = deque([[start]])\n    while to_visit:\n        path = to_visit.popleft()\n        node = path[-1]\n        if node == goal:\n            yield path\n        else:\n            for next_node in graph[node].difference(path):",
        "detail": ".gitbook.assets.bfs_paths_dict (1)",
        "documentation": {}
    },
    {
        "label": "bfs_paths_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_paths_dict (2)",
        "description": ".gitbook.assets.bfs_paths_dict (2)",
        "peekOfCode": "def bfs_paths_dict(graph: Mapping[Node, set[Node]], start: Node, goal: Node) -> Iterable[list[Node]]:\n    \"\"\"Find all the paths from start to goal using BFS on a dict.\"\"\"\n    to_visit = deque([[start]])\n    while to_visit:\n        path = to_visit.popleft()\n        node = path[-1]\n        if node == goal:\n            yield path\n        else:\n            for next_node in graph[node].difference(path):",
        "detail": ".gitbook.assets.bfs_paths_dict (2)",
        "documentation": {}
    },
    {
        "label": "bfs_paths_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_paths_dict",
        "description": ".gitbook.assets.bfs_paths_dict",
        "peekOfCode": "def bfs_paths_dict(graph: Mapping[Node, set[Node]], start: Node, goal: Node) -> Iterable[list[Node]]:\n    \"\"\"Find all the paths from start to goal using BFS on a dict.\"\"\"\n    to_visit = deque([[start]])\n    while to_visit:\n        path = to_visit.popleft()\n        node = path[-1]\n        if node == goal:\n            yield path\n        else:\n            for next_node in graph[node].difference(path):",
        "detail": ".gitbook.assets.bfs_paths_dict",
        "documentation": {}
    },
    {
        "label": "bfs_search_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_search_dict (1)",
        "description": ".gitbook.assets.bfs_search_dict (1)",
        "peekOfCode": "def bfs_search_dict(graph: Mapping[Node, Iterable[Node]], start: Node, predicate: Callable[[Node], bool]) -> bool:\n    \"\"\"Find the closest node to start that matches the predicate using breadth first search.\"\"\"\n    visited = set()\n    to_visit = deque([start])\n    while to_visit:\n        node = to_visit.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        if predicate(node):",
        "detail": ".gitbook.assets.bfs_search_dict (1)",
        "documentation": {}
    },
    {
        "label": "bfs_search_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_search_dict",
        "description": ".gitbook.assets.bfs_search_dict",
        "peekOfCode": "def bfs_search_dict(graph: Mapping[Node, Iterable[Node]], start: Node, predicate: Callable[[Node], bool]) -> bool:\n    \"\"\"Find the closest node to start that matches the predicate using breadth first search.\"\"\"\n    visited = set()\n    to_visit = deque([start])\n    while to_visit:\n        node = to_visit.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        if predicate(node):",
        "detail": ".gitbook.assets.bfs_search_dict",
        "documentation": {}
    },
    {
        "label": "bfs_search_grid",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_search_grid (1)",
        "description": ".gitbook.assets.bfs_search_grid (1)",
        "peekOfCode": "def bfs_search_grid(grid: Sequence[Sequence[int]], start: tuple[int, int], goal: tuple[int, int]) -> bool:\n    \"\"\"On a grid of 0s and 1s, find if start is connected to goal via a path of 1s.\"\"\"\n    rows = range(len(grid))\n    cols = range(len(grid[0]))\n    seen = {start}\n    to_visit = deque([start])\n    while to_visit:\n        r, c = to_visit.popleft()\n        if (r, c) == goal:\n            return True",
        "detail": ".gitbook.assets.bfs_search_grid (1)",
        "documentation": {}
    },
    {
        "label": "bfs_search_grid",
        "kind": 2,
        "importPath": ".gitbook.assets.bfs_search_grid",
        "description": ".gitbook.assets.bfs_search_grid",
        "peekOfCode": "def bfs_search_grid(grid: Sequence[Sequence[int]], start: tuple[int, int], goal: tuple[int, int]) -> bool:\n    \"\"\"On a grid of 0s and 1s, find if start is connected to goal via a path of 1s.\"\"\"\n    rows = range(len(grid))\n    cols = range(len(grid[0]))\n    seen = {start}\n    to_visit = deque([start])\n    while to_visit:\n        r, c = to_visit.popleft()\n        if (r, c) == goal:\n            return True",
        "detail": ".gitbook.assets.bfs_search_grid",
        "documentation": {}
    },
    {
        "label": "bipartite_matching_single",
        "kind": 2,
        "importPath": ".gitbook.assets.bipartite_matching_single (1)",
        "description": ".gitbook.assets.bipartite_matching_single (1)",
        "peekOfCode": "def bipartite_matching_single(graph: Sequence[int]) -> list[int]:\n    matches = list(graph)\n    in_degrees = [0] * len(graph)  # This is an alternate to collections.Counter when the keys are 0-n.\n    for target in graph:\n        in_degrees[target] += 1\n    zero_in_degrees = [node for node, in_degree in enumerate(in_degrees) if not in_degree]\n    while zero_in_degrees:\n        node = zero_in_degrees.pop()\n        target = matches[node]\n        matches[node] = node",
        "detail": ".gitbook.assets.bipartite_matching_single (1)",
        "documentation": {}
    },
    {
        "label": "bipartite_matching_single",
        "kind": 2,
        "importPath": ".gitbook.assets.bipartite_matching_single (2)",
        "description": ".gitbook.assets.bipartite_matching_single (2)",
        "peekOfCode": "def bipartite_matching_single(graph: Sequence[int]) -> list[int]:\n    matches = list(graph)\n    in_degrees = [0] * len(graph)  # This is an alternate to collections.Counter when the keys are 0-n.\n    for target in graph:\n        in_degrees[target] += 1\n    zero_in_degrees = [node for node, in_degree in enumerate(in_degrees) if not in_degree]\n    while zero_in_degrees:\n        node = zero_in_degrees.pop()\n        target = matches[node]\n        matches[node] = node",
        "detail": ".gitbook.assets.bipartite_matching_single (2)",
        "documentation": {}
    },
    {
        "label": "bipartite_matching_single",
        "kind": 2,
        "importPath": ".gitbook.assets.bipartite_matching_single",
        "description": ".gitbook.assets.bipartite_matching_single",
        "peekOfCode": "def bipartite_matching_single(graph: Sequence[int]) -> list[int]:\n    matches = list(graph)\n    in_degrees = [0] * len(graph)  # This is an alternate to collections.Counter when the keys are 0-n.\n    for target in graph:\n        in_degrees[target] += 1\n    zero_in_degrees = [node for node, in_degree in enumerate(in_degrees) if not in_degree]\n    while zero_in_degrees:\n        node = zero_in_degrees.pop()\n        target = matches[node]\n        matches[node] = node",
        "detail": ".gitbook.assets.bipartite_matching_single",
        "documentation": {}
    },
    {
        "label": "bisect_search",
        "kind": 2,
        "importPath": ".gitbook.assets.bisect_search (1)",
        "description": ".gitbook.assets.bisect_search (1)",
        "peekOfCode": "def bisect_search(predicate: Callable[[int], bool], low: int, high: int) -> int:\n    \"\"\"Find the lowest int between low and high where predicate(int) is True.\"\"\"\n    while low < high:\n        mid = low + (high - low) // 2  # Avoids integer overflow compared to mid = (low + high) // 2\n        if predicate(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low",
        "detail": ".gitbook.assets.bisect_search (1)",
        "documentation": {}
    },
    {
        "label": "bisect_search",
        "kind": 2,
        "importPath": ".gitbook.assets.bisect_search",
        "description": ".gitbook.assets.bisect_search",
        "peekOfCode": "def bisect_search(predicate: Callable[[int], bool], low: int, high: int) -> int:\n    \"\"\"Find the lowest int between low and high where predicate(int) is True.\"\"\"\n    while low < high:\n        mid = low + (high - low) // 2  # Avoids integer overflow compared to mid = (low + high) // 2\n        if predicate(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low",
        "detail": ".gitbook.assets.bisect_search",
        "documentation": {}
    },
    {
        "label": "bst_make_balanced_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.bst_make_balanced_recur (1)",
        "description": ".gitbook.assets.bst_make_balanced_recur (1)",
        "peekOfCode": "def bst_make_balanced_recur(values: Sequence[int]) -> Optional[BTNode]:\n    \"\"\"Make a balanced binary search tree from a sorted sequence of values.\"\"\"\n    if not values:\n        return None\n    mid = len(values) // 2\n    root = BTNode(values[mid])\n    root.left = bst_make_balanced_recur(values[:mid])\n    root.right = bst_make_balanced_recur(values[mid + 1:])\n    return root",
        "detail": ".gitbook.assets.bst_make_balanced_recur (1)",
        "documentation": {}
    },
    {
        "label": "bst_make_balanced_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.bst_make_balanced_recur",
        "description": ".gitbook.assets.bst_make_balanced_recur",
        "peekOfCode": "def bst_make_balanced_recur(values: Sequence[int]) -> Optional[BTNode]:\n    \"\"\"Make a balanced binary search tree from a sorted sequence of values.\"\"\"\n    if not values:\n        return None\n    mid = len(values) // 2\n    root = BTNode(values[mid])\n    root.left = bst_make_balanced_recur(values[:mid])\n    root.right = bst_make_balanced_recur(values[mid + 1:])\n    return root",
        "detail": ".gitbook.assets.bst_make_balanced_recur",
        "documentation": {}
    },
    {
        "label": "bt_inorder_traversal_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.bt_inorder_traversal_recur (1)",
        "description": ".gitbook.assets.bt_inorder_traversal_recur (1)",
        "peekOfCode": "def bt_inorder_traversal_recur(root: Optional[BTNode]) -> Iterable[BTNode]:\n    if root is not None:\n        yield from bt_inorder_traversal_recur(root.left)\n        yield root\n        yield from bt_inorder_traversal_recur(root.right)",
        "detail": ".gitbook.assets.bt_inorder_traversal_recur (1)",
        "documentation": {}
    },
    {
        "label": "bt_inorder_traversal_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.bt_inorder_traversal_recur",
        "description": ".gitbook.assets.bt_inorder_traversal_recur",
        "peekOfCode": "def bt_inorder_traversal_recur(root: Optional[BTNode]) -> Iterable[BTNode]:\n    if root is not None:\n        yield from bt_inorder_traversal_recur(root.left)\n        yield root\n        yield from bt_inorder_traversal_recur(root.right)",
        "detail": ".gitbook.assets.bt_inorder_traversal_recur",
        "documentation": {}
    },
    {
        "label": "bt_level_order_traversal_iter",
        "kind": 2,
        "importPath": ".gitbook.assets.bt_level_order_traversal_iter (1)",
        "description": ".gitbook.assets.bt_level_order_traversal_iter (1)",
        "peekOfCode": "def bt_level_order_traversal_iter(root: BTNode) -> Iterable[list[BTNode]]:\n    # would do a null check here if root was Optional\n    level = deque([root])\n    while level:\n        # modify this line if you needed to grab the values\n        yield list(level)  # copy so it's not messed with\n        for _ in range(len(level)):\n            node = level.popleft()\n            for child in [node.left, node.right]:\n                if child is not None:",
        "detail": ".gitbook.assets.bt_level_order_traversal_iter (1)",
        "documentation": {}
    },
    {
        "label": "bt_level_order_traversal_iter",
        "kind": 2,
        "importPath": ".gitbook.assets.bt_level_order_traversal_iter",
        "description": ".gitbook.assets.bt_level_order_traversal_iter",
        "peekOfCode": "def bt_level_order_traversal_iter(root: BTNode) -> Iterable[list[BTNode]]:\n    # would do a null check here if root was Optional\n    level = deque([root])\n    while level:\n        # modify this line if you needed to grab the values\n        yield list(level)  # copy so it's not messed with\n        for _ in range(len(level)):\n            node = level.popleft()\n            for child in [node.left, node.right]:\n                if child is not None:",
        "detail": ".gitbook.assets.bt_level_order_traversal_iter",
        "documentation": {}
    },
    {
        "label": "celebrity",
        "kind": 2,
        "importPath": ".gitbook.assets.celebrity (1)",
        "description": ".gitbook.assets.celebrity (1)",
        "peekOfCode": "def celebrity(knows: Callable[[int, int], bool], n: int) -> Optional[int]:\n    candidate = 0\n    for node in range(1, n):\n        if knows(candidate, node):\n            candidate = node\n    if any(knows(candidate, node) for node in range(candidate)):\n        return None\n    if any(not knows(node, candidate) for node in range(n)):\n        return None\n    return candidate",
        "detail": ".gitbook.assets.celebrity (1)",
        "documentation": {}
    },
    {
        "label": "celebrity",
        "kind": 2,
        "importPath": ".gitbook.assets.celebrity",
        "description": ".gitbook.assets.celebrity",
        "peekOfCode": "def celebrity(knows: Callable[[int, int], bool], n: int) -> Optional[int]:\n    candidate = 0\n    for node in range(1, n):\n        if knows(candidate, node):\n            candidate = node\n    if any(knows(candidate, node) for node in range(candidate)):\n        return None\n    if any(not knows(node, candidate) for node in range(n)):\n        return None\n    return candidate",
        "detail": ".gitbook.assets.celebrity",
        "documentation": {}
    },
    {
        "label": "counting_sort_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_dict (1)",
        "description": ".gitbook.assets.counting_sort_dict (1)",
        "peekOfCode": "def counting_sort_dict(items: Iterable[T], key: Callable[[T], int] = lambda x: x) -> Iterable[T]:\n    groups = defaultdict(list)\n    for item in items:\n        groups[key(item)].append(item)\n    for k in range(min(groups), max(groups) + 1):\n        yield from groups[k]",
        "detail": ".gitbook.assets.counting_sort_dict (1)",
        "documentation": {}
    },
    {
        "label": "counting_sort_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_dict (2)",
        "description": ".gitbook.assets.counting_sort_dict (2)",
        "peekOfCode": "def counting_sort_dict(items: Iterable[T], key: Callable[[T], int] = lambda x: x) -> Iterable[T]:\n    groups = defaultdict(list)\n    for item in items:\n        groups[key(item)].append(item)\n    for k in range(min(groups), max(groups) + 1):\n        yield from groups[k]",
        "detail": ".gitbook.assets.counting_sort_dict (2)",
        "documentation": {}
    },
    {
        "label": "counting_sort_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_dict",
        "description": ".gitbook.assets.counting_sort_dict",
        "peekOfCode": "def counting_sort_dict(items: Iterable[T], key: Callable[[T], int] = lambda x: x) -> Iterable[T]:\n    groups = defaultdict(list)\n    for item in items:\n        groups[key(item)].append(item)\n    for k in range(min(groups), max(groups) + 1):\n        yield from groups[k]",
        "detail": ".gitbook.assets.counting_sort_dict",
        "documentation": {}
    },
    {
        "label": "counting_sort_list",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_list (1)",
        "description": ".gitbook.assets.counting_sort_list (1)",
        "peekOfCode": "def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):\n    max_value = max(map(key, items))\n    count = [0] * (max_value + 1)\n    for item in items:\n        count[key(item)] += 1\n    count = list(accumulate(count, initial=0))\n    ret = [None] * len(items)\n    for item in items:\n        i = count[key(item)]\n        ret[i] = item",
        "detail": ".gitbook.assets.counting_sort_list (1)",
        "documentation": {}
    },
    {
        "label": "counting_sort_list",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_list (2)",
        "description": ".gitbook.assets.counting_sort_list (2)",
        "peekOfCode": "def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):\n    max_value = max(map(key, items))\n    count = [0] * (max_value + 1)\n    for item in items:\n        count[key(item)] += 1\n    count = list(accumulate(count, initial=0))\n    ret = [None] * len(items)\n    for item in items:\n        i = count[key(item)]\n        ret[i] = item",
        "detail": ".gitbook.assets.counting_sort_list (2)",
        "documentation": {}
    },
    {
        "label": "counting_sort_list",
        "kind": 2,
        "importPath": ".gitbook.assets.counting_sort_list",
        "description": ".gitbook.assets.counting_sort_list",
        "peekOfCode": "def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):\n    max_value = max(map(key, items))\n    count = [0] * (max_value + 1)\n    for item in items:\n        count[key(item)] += 1\n    count = list(accumulate(count, initial=0))\n    ret = [None] * len(items)\n    for item in items:\n        i = count[key(item)]\n        ret[i] = item",
        "detail": ".gitbook.assets.counting_sort_list",
        "documentation": {}
    },
    {
        "label": "threeCharsDistinct",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def threeCharsDistinct(s):\n    count = 0\n    for i in range(len(s)):\n        if i < len(s) - 2:\n            # print(i)\n            if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n                count += 1\n    return count\n# print(threeCharsDistinct(s))\nsentence = \"Man bites dog\"",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverseSentence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def reverseSentence(sentence):\n    words_array = sentence.split(' ')\n    words_reversed = ' '.join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "incorrectPasscodeAttempts",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def incorrectPasscodeAttempts(passcode, attempts):\n    count = 0\n    indexes = []\n    if len(attempts) < 10 and passcode not in attempts:\n        return False\n    for attempt in attempts:\n        print('attempt:', attempt)\n        if attempt != passcode:\n            print('count before:', count)\n            count += 1",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "digitSumsDifference",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))\n        else:",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "digitsManipulations",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n#\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "countVowelConsonant",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2\n    return vowel_count + const_count",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "contains_duplicate_2",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "def contains_duplicate_2(nums):\n    # overall runtime: O(nlogn + n) --> O(n log n)\n    # space complexity: O(1)\n    nums.sort()  # sorting is usually O(n log n)\n    # nums.sort() sorts it in place\n    # everything below this line is O(n)\n    i = 0  # O(1)\n    while i < len(nums) - 1:  # up to O(n)\n        if nums[i] == nums[i + 1]:  # O(1)\n            return True",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "s = 'abacaba'\n# def threeCharsDistinct(s):\n#     count = 0\n#\n#     for i in range(len(s)):\n#         if i < 6:\n#             if s[0] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n#                 count += 1\n#     print(count)\ndef threeCharsDistinct(s):",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "sentence = \"Man bites dog\"\ndef reverseSentence(sentence):\n    words_array = sentence.split(' ')\n    words_reversed = ' '.join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "passcode",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "passcode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",\n            \"8888\",\n            \"2222\",\n            \"7777\",\n            \"0000\",\n            \"6666\",",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "attempts",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "attempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",\n            \"8888\",\n            \"2222\",\n            \"7777\",\n            \"0000\",\n            \"6666\",\n            \"7285\",",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "n = 412\ndef digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "n = 123456\ndef digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n#\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects (1)",
        "description": ".gitbook.assets.cs-week1-projects (1)",
        "peekOfCode": "s = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2",
        "detail": ".gitbook.assets.cs-week1-projects (1)",
        "documentation": {}
    },
    {
        "label": "threeCharsDistinct",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def threeCharsDistinct(s):\n    count = 0\n    for i in range(len(s)):\n        if i < len(s) - 2:\n            # print(i)\n            if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n                count += 1\n    return count\n# print(threeCharsDistinct(s))\nsentence = \"Man bites dog\"",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "reverseSentence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def reverseSentence(sentence):\n    words_array = sentence.split(' ')\n    words_reversed = ' '.join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "incorrectPasscodeAttempts",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def incorrectPasscodeAttempts(passcode, attempts):\n    count = 0\n    indexes = []\n    if len(attempts) < 10 and passcode not in attempts:\n        return False\n    for attempt in attempts:\n        print('attempt:', attempt)\n        if attempt != passcode:\n            print('count before:', count)\n            count += 1",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "digitSumsDifference",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))\n        else:",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "digitsManipulations",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n#\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "countVowelConsonant",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2\n    return vowel_count + const_count",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "contains_duplicate_2",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "def contains_duplicate_2(nums):\n    # overall runtime: O(nlogn + n) --> O(n log n)\n    # space complexity: O(1)\n    nums.sort()  # sorting is usually O(n log n)\n    # nums.sort() sorts it in place\n    # everything below this line is O(n)\n    i = 0  # O(1)\n    while i < len(nums) - 1:  # up to O(n)\n        if nums[i] == nums[i + 1]:  # O(1)\n            return True",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "s = 'abacaba'\n# def threeCharsDistinct(s):\n#     count = 0\n#\n#     for i in range(len(s)):\n#         if i < 6:\n#             if s[0] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n#                 count += 1\n#     print(count)\ndef threeCharsDistinct(s):",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "sentence = \"Man bites dog\"\ndef reverseSentence(sentence):\n    words_array = sentence.split(' ')\n    words_reversed = ' '.join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "passcode",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "passcode = '1111'\nattempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",\n            \"8888\",\n            \"2222\",\n            \"7777\",\n            \"0000\",\n            \"6666\",",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "attempts",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "attempts = [\"1111\",\n            \"4444\",\n            \"9999\",\n            \"3333\",\n            \"8888\",\n            \"2222\",\n            \"7777\",\n            \"0000\",\n            \"6666\",\n            \"7285\",",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "n = 412\ndef digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "n = 123456\ndef digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n#\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week1-projects",
        "description": ".gitbook.assets.cs-week1-projects",
        "peekOfCode": "s = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2",
        "detail": ".gitbook.assets.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "remove_duplicates",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def remove_duplicates(nums):\n    # Your code here\n    i = 0\n    while i < len(nums) - 1:\n        if nums[i] == nums[i + 1]:\n            nums.pop(i + 1)\n        else:\n            i = i + 1\n    return nums\n\"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "contains_duplicate",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def contains_duplicate(nums):\n    # Your code here\n    num_set = set(nums)\n    if len(num_set) == len(nums):\n        return False\n    else:\n        return True\n# print(contains_duplicate([1, 3, 3, 2, 1]))\n\"\"\"\nGiven two strings `a` and `b`, write a function to determine if `a` is an",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def is_anagram(a, b):\n    # Your code here\n    pass\n# # \"\"\"\n# # Example One\n# # \"\"\"\n# # my_list1 = [1, 2, 3, 4, 5, 6]\n# # my_list2 = my_list1\n# # # How would you verify that my_list1 and my_list2 have the same identity?\n# # print(id(my_list1) == id(my_list2))",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def fibonacci(n):\n    lst = [0, 1]\n    for i in range(2, n):\n        lst.append(lst[i - 2] + lst[i - 1])\n    return lst[n - 1]\n# # O(n)\n#\n# \"\"\"\n# Use Big O notation to classify the space complexity of the function below.\n# \"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacci_two",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def fibonacci_two(n):\n    x, y, z = 0, 1, None\n    if n == 0:\n        return x\n    if n == 1:\n        return y\n    for i in range(2, n):\n        z = x + y\n        x, y = y, z\n    return z",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "do_something",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def do_something(n):\n    lst = []\n    for i in range(n):\n        for j in range(n):\n            lst.append(i + j)\n    return lst\n# O(n^2)\n# numbers = [2, 0, 0, 0]\n#\n#",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "removeEvens",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def removeEvens(numbers):\n    return [num for num in numbers if num % 2 != 0]\n# below code didn't pass tests above did\n# for num in numbers:\n#     if num % 2 == 0 and num != 0:\n#         numbers.remove(num)\n# return numbers\n# print(removeEvens(numbers))\nimport statistics\nsequence = [-1, 3, -2, 2]",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "arrayMedian",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n#\n# s = \"TuVwXYZ\"\n#\n# # s = \"ABCDEFFDEfghCBA\"\n#\n# # def originalIncreasingSubstrings(s):\n# #     string = ''",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "additionWithoutCarrying",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:\n        larger = param1",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "evenDigitsNumber",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n#\n# For example, if k = 3, then the string \"bad\" would be considered good, since the greatest difference in ASCII codes is 3 (between the a and d characters). The string \"nice\" would not be considered good, since there's a difference of 11 between the c and n characters.",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "goodSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')\n        if ord(strToSplit[i]) < smallest:",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "to_lower_case",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def to_lower_case(string):\n    result = ''\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))\n\"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "roman_to_integer",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n        'IV': 4,",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "find_lucky",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "def find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)\n# print(find_lucky(lst))",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "sequence = [-1, 3, -2, 2]\ndef arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n#\n# s = \"TuVwXYZ\"\n#\n# # s = \"ABCDEFFDEfghCBA\"\n#\n# # def originalIncreasingSubstrings(s):",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "s = \"f\"\ndef increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "param1",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "param1 = 456\nparam2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "param2",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "param2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "a = [12, 134, 111, 1111, 10]\ndef evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n#",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "k = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "k = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "strToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "k = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "string = \"LambdaSchool\"\ndef to_lower_case(string):\n    result = ''\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "roman = 'IV'\nroman = 'XII'\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "roman = 'XII'\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "roman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects (1)",
        "description": ".gitbook.assets.cs-week2-projects (1)",
        "peekOfCode": "lst = [2, 2, 3, 3, 3, 4, 4, 4, 4]\n#  O(n^2) because counting in the loop...\ndef find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)",
        "detail": ".gitbook.assets.cs-week2-projects (1)",
        "documentation": {}
    },
    {
        "label": "remove_duplicates",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def remove_duplicates(nums):\n    # Your code here\n    i = 0\n    while i < len(nums) - 1:\n        if nums[i] == nums[i + 1]:\n            nums.pop(i + 1)\n        else:\n            i = i + 1\n    return nums\n\"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "contains_duplicate",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def contains_duplicate(nums):\n    # Your code here\n    num_set = set(nums)\n    if len(num_set) == len(nums):\n        return False\n    else:\n        return True\n# print(contains_duplicate([1, 3, 3, 2, 1]))\n\"\"\"\nGiven two strings `a` and `b`, write a function to determine if `a` is an",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def is_anagram(a, b):\n    # Your code here\n    pass\n# # \"\"\"\n# # Example One\n# # \"\"\"\n# # my_list1 = [1, 2, 3, 4, 5, 6]\n# # my_list2 = my_list1\n# # # How would you verify that my_list1 and my_list2 have the same identity?\n# # print(id(my_list1) == id(my_list2))",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def fibonacci(n):\n    lst = [0, 1]\n    for i in range(2, n):\n        lst.append(lst[i - 2] + lst[i - 1])\n    return lst[n - 1]\n# # O(n)\n#\n# \"\"\"\n# Use Big O notation to classify the space complexity of the function below.\n# \"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "fibonacci_two",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def fibonacci_two(n):\n    x, y, z = 0, 1, None\n    if n == 0:\n        return x\n    if n == 1:\n        return y\n    for i in range(2, n):\n        z = x + y\n        x, y = y, z\n    return z",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "do_something",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def do_something(n):\n    lst = []\n    for i in range(n):\n        for j in range(n):\n            lst.append(i + j)\n    return lst\n# O(n^2)\n# numbers = [2, 0, 0, 0]\n#\n#",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "removeEvens",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def removeEvens(numbers):\n    return [num for num in numbers if num % 2 != 0]\n# below code didn't pass tests above did\n# for num in numbers:\n#     if num % 2 == 0 and num != 0:\n#         numbers.remove(num)\n# return numbers\n# print(removeEvens(numbers))\nimport statistics\nsequence = [-1, 3, -2, 2]",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "arrayMedian",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n#\n# s = \"TuVwXYZ\"\n#\n# # s = \"ABCDEFFDEfghCBA\"\n#\n# # def originalIncreasingSubstrings(s):\n# #     string = ''",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "additionWithoutCarrying",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:\n        larger = param1",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "evenDigitsNumber",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n#\n# For example, if k = 3, then the string \"bad\" would be considered good, since the greatest difference in ASCII codes is 3 (between the a and d characters). The string \"nice\" would not be considered good, since there's a difference of 11 between the c and n characters.",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "goodSubstrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')\n        if ord(strToSplit[i]) < smallest:",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "to_lower_case",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def to_lower_case(string):\n    result = ''\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))\n\"\"\"",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman_to_integer",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n        'IV': 4,",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "find_lucky",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "def find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)\n# print(find_lucky(lst))",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "sequence = [-1, 3, -2, 2]\ndef arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n#\n# s = \"TuVwXYZ\"\n#\n# # s = \"ABCDEFFDEfghCBA\"\n#\n# # def originalIncreasingSubstrings(s):",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "s = \"f\"\ndef increasingSubstrings(s):\n    string = ''\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "param1",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "param1 = 456\nparam2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "param2",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "param2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "a = [12, 134, 111, 1111, 10]\ndef evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n#",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "k = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "k = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "k = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = ''\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "string = \"LambdaSchool\"\ndef to_lower_case(string):\n    result = ''\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "roman = 'IV'\nroman = 'XII'\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "roman = 'XII'\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "roman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-week2-projects",
        "description": ".gitbook.assets.cs-week2-projects",
        "peekOfCode": "lst = [2, 2, 3, 3, 3, 4, 4, 4, 4]\n#  O(n^2) because counting in the loop...\ndef find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)",
        "detail": ".gitbook.assets.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\nx = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode('X')",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\n[1, 3, 4, 6]\n\"\"\"\nNote: Your solution should have O(n) time complexity, where n is the number of elements in l, since this is what you will be asked to accomplish in an interview.\nYou have a singly linked list l, which is sorted in strictly increasing order, and an integer value. Add value to the list l, preserving its original sorting.\nNote: in examples below and tests preview linked lists are presented as arrays just for simplicity of visualization: in real data you will be given a head node l of the linked list\nExample",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)\n        # check if queue is empty\n        if self.is_empty():\n            self.front = new_node\n            self.rear = new_node",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    # my code for peek method\n    def peek(self, item):\n        return self.data[-1]\n    def pop(self):\n        if len(self.data) > 0:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)\n        # set current top to new node's next\n        new_node.next = self.top\n        # reset the top pointer to the new node\n        self.top = new_node",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Stack(object):\n    def __init__(self):\n        \"\"\"Initialize an empty stack\"\"\"\n        self.items = []\n    def push(self, item):\n        \"\"\"Push a new item onto the stack\"\"\"\n        self.items.append(item)\n    def pop(self):\n        \"\"\"Remove and return the last item\"\"\"\n        # If the stack is empty, return None",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class MaxStack(object):\n    def __init__(self):\n        # Your code here\n        self.stack = Stack()\n        # self.head = []\n        self.max_stack = Stack()\n    def push(self, item):\n        \"\"\"Add a new item onto the top of our stack.\"\"\"\n        # Your code here\n        # self.head.append(item)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n        # Your code here\n        self.stack1 = Stack()\n        self.stack2 = Stack()\n    def enqueue(self, item):\n        # Your code here\n        self.stack1.push(item)\n    def dequeue(self):\n        # Your code here",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()\ndef queueOnStacks(requests):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "pivot_index",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def pivot_index(nums):\n    if len(nums) <= 1:\n        return -1\n    left = 0\n    right = sum(nums)\n    for i in range(len(nums)):\n        right -= nums[i]\n        if right == left:\n            return i\n        left += nums[i]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "plus_one",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def plus_one(digits):\n    # check the last digit if its not 9 we just add 1\n    # if it is a 9 make it 0\n    # go left check 2nd to last if its not a 9 add 1\n    # if it is a 9\n    index = len(digits) - 1\n    while index >= 0 and digits[index] == 9:\n        digits[index] = 0\n        index -= 1\n    if index == -1:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "buyAndSellStock",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):\n        # only check if the selected number minus the smallest number before",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def alphabeticShift(inputString):\n    new_string = ''\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':\n            check.append(paren)\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "delete_node",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:\n        # Copy a pointer to the next element\n        # before we overwrite current_node.next\n        next_node = current_node.next\n        # Reverse the 'next' pointer",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "insertValueIntoSortedLinkedList",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def insertValueIntoSortedLinkedList(l, value):\n    # create a new node with the value\n    node = ListNode(value)\n    # if there is no list return the new node\n    if l == None:\n        return node\n    else:\n        # else if the list.value (first item in the list) > the new value\n        if l.value > value:\n            # set new values as the first item in the list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:\n        # if either list becomes empty join lists\n        if l1 is None:\n            end.next = l2\n            break",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverseNodesInKGroups",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list\n    prev = new_node\n    while True:\n        # set the start to the new node next\n        start = prev.next",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def reverse_list(start, end):\n    # set the last reversed group to the new start\n    old_reversed = start\n    # set the new current to the start\n    current = start\n    # set next node to the node start is pointing to\n    next_node = start.next\n    # while the current node is not the last node\n    while current != end:\n        # iterate",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':\n            continue\n        if paren == '(' or paren == '{' or paren == '[':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "queueOnStacks",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def queueOnStacks(requests):\n    left = Stack()\n    right = Stack()\n    def insert(x):\n        left.push(x)\n        print('queue:', left.items)\n    def remove():\n        if len(right.items) == 0:\n            while len(left.items) > 0:\n                shifted = left.pop()",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "validBracketSequence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def validBracketSequence(sequence):\n    pairs = dict(zip('(,[,{', '),],}'))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack\n# print(validBracketSequence(sequence))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n\n    for i in range(2, n):\n        # add seq at i - 2 (0 to start) and seq at i - 1 (1 to start)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "csBinarySearch",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def csBinarySearch(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[guess] < target:\n            min = guess + 1\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "csSearchRotatedSortedArray",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def csSearchRotatedSortedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        # print(f'min: {nums[min]} max: {nums[max]} guess:{nums[guess]} target:'\n        #       f' {target}')\n        # if the guess is the target we got it and return the guess\n        if nums[guess] == target:\n            # print('guessed the target')",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1\n    for idx in range(len(arr)):\n        # check if the item at the current index is equal to the target\n        if arr[i] == target:\n            # return the current index as the match\n            return i\n        i -= 1\n    # if we were able to loop through the entire array, the target is not present",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "recursive_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def recursive_search(arr, target):\n    if arr[0] == target:\n        return True\n    elif len(arr[1:]) > 1:\n        return recursive_search(arr[1:], target)\n    return False\n# print(recursive_search(arr, target))\n\"\"\"\nBinary Search\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def binary_search(arr, target):\n    # 1. Declare min = 0 and max = length of array - 1\n    min = 0\n    max = len(arr) - 1\n    while not max < min:\n        # 2. Figure out the guess value by getting the middle integer between min and max\n        guess = (max + min) // 2\n        # 3. if array[guess] equals the target, we found the element, return the index\n        if arr[guess] == target:\n            return guess",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "binary_recursive_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:\n        return binary_recursive_search(arr, target, guess + 1, max_index)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    min = 0\n    max = len(surnames) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        if surnames[guess] < surnames[guess + 1] and surnames[guess] < surnames[\n            guess - 1]:\n            return guess\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    # UNDERSTAND\n    # [ 6,   7, 8, 0, 1, 2, 3, 4, 5]\n    #           min max\n    #           mid\n    # [ 7, 0, 1,  2, 3, 4, 5, 6]\n    #  min\n    # max\n    # mid",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "firstDraftWithTypo",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:\n        # if containsTypo(n[guess]) and not containsTypo(n[guess -1]):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "eating_cookies",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)\n    cache[0] = 1",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "removeAdjacent",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s\n    new_str = s[0]\n    # iterate the string\n    for letter in s:\n        # if the next letter is the same as previous continue\n        if letter == new_str[len(new_str) - 1]:\n            continue",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverse_String",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***\n---------------------------",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def reverseLinkedList(l):\n    cur = l\n    prev = None\n    next = None\n    while cur:\n        next = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next\n    return prev",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "checkBlanagrams",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions\n        if sort1[i] != sort2[i]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "findValueSortedShiftedArray",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "def findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:\n                max = guess",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "nums = [1, 7, 3, 6, 5, 6]\n# nums = [1,2,3]\n#  O(N^2) solution\n# def pivot_index(nums):\n#     # iterate array starting at index 1\n#     # get sum of items on left of i and compare to sum of items on right of i\n#     # if they are equal return i else keep going to the next i\n#     for i in range(len(nums)):\n#         left = sum(nums[:i])\n#         right = sum(nums[i + 1:])",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "prices = [3, 100, 1, 97]\n#\n# prices = []\n# prices = [61, 91, 6, 15, 28, 30, 39, 69, 78, 81, 62, 38, 56, 69, 22, 95, 47, 82,\n#           52, 64, 74, 97, 60, 68, 5, 23, 45, 55, 66, 57, 26, 4, 21, 65, 55, 50,\n#           41, 88, 39, 84, 77, 5, 76, 11, 3, 51, 96, 100, 13, 26, 79, 98, 84, 66,\n#           93, 65, 98, 60, 57, 35, 12, 40, 83, 62, 46, 60, 26, 94, 59, 29, 70,\n#           34, 83, 98, 89, 57, 71, 44, 23, 43, 55, 1, 70, 29, 44, 10, 70, 83, 95,\n#           96, 97, 84, 23, 16, 34, 55, 59, 73, 17, 73]\n# def buyAndSellStock(prices):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "prices = [6, 3, 1, 2, 5, 4]\nprices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "prices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "prices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "inputString = \"crazy\"\ndef alphabeticShift(inputString):\n    new_string = ''\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "validParenthesesSequence(s) = true;\nFor s = \"()()())\", the output should be\nvalidParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "validParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "s = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "s = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':\n            check.append(paren)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "x = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "y = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "z = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "x.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "y.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "x = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "y = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "z = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "x.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "y.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.\nIn order to do this in O(n) time, you should only have to traverse the list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "max_stack",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "max_stack = MaxStack()\nmax_stack.push(1)\nmax_stack.push(2)\nmax_stack.push(5)\nmax_stack.pop()\n# print(max_stack.get_max())\n\"\"\"\nYour goal is to define a `Queue` class that uses two stacks. Your `Queue` class\nshould have an `enqueue()` method and a `dequeue()` method that ensures a\n\"first in first out\" (FIFO) order.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "code = \"{ [ ] ( ) }\"\ncode = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "code = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "code = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':\n            continue",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "queueOnStacks(requests)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "queueOnStacks(requests) = [1, 2].\nAfter the first request, the queue is {1}; after the second it is {1, 2}. Then we do the third request, \"pop\", and add the first element of the queue 1 to the answer array. The queue becomes {2}. After the fourth request, the queue is {2, 3}. Then we perform \"pop\" again and add 2 to the answer array, and the queue becomes {3}.\n\"\"\"\nrequests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "requests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "sequence = \"()\"\ndef validBracketSequence(sequence):\n    pairs = dict(zip('(,[,{', '),],}'))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 1 = 0 + 1 = F0 + F1.\nFor n = 11, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "fibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "2^n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "2^n = 64\nlog_2 64 = 6\nWrite an exponential expression that is identical to this logarithmic expression:\nlog_2 128 = n\n2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "2^7",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.\n\"\"\"\ndef linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case ",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "target = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case \n- the function must call itself",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "target = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "surnames = [\n    'liu',\n    'mcdowell',\n    'nixon',\n    'sparks',\n    'zhang',\n    'ahmed',  # <-- rotates here!\n    'brandt',\n    'davenport',\n    'farley',",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "surnames = [\n    'sparks',\n    'zhang',\n    'liu',\n    'ahmed',  # <-- rotates here!\n    'brandt',\n    'davenport',\n    'farley',\n    'glover',\n    'kennedy',",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "n = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndef firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "n = 3\ndef eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "removeAdjacent(s) = \"a\";\nFor s = \"abccaaab\", the output should be\nremoveAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "removeAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s\n    new_str = s[0]\n    # iterate the string",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "str = 'reverse'\ndef reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "checkPalindrome(inputString) = true;\nFor inputString = \"abac\", the output should be\ncheckPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "checkPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "checkPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "inputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "inputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList(l)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "reverseLinkedList(l) = [5, 4, 3, 2, 1].\n\"\"\"\n# Singly-linked lists are already defined with this interface:\n# class ListNode(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.next = None\n#\ndef reverseLinkedList(l):\n    cur = l",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "word1",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "word1 = \"tangpam\"\nword2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "word2",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "word2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "nums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "description": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "peekOfCode": "target = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects (1)",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\nx = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode('X')",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\n[1, 3, 4, 6]\n\"\"\"\nNote: Your solution should have O(n) time complexity, where n is the number of elements in l, since this is what you will be asked to accomplish in an interview.\nYou have a singly linked list l, which is sorted in strictly increasing order, and an integer value. Add value to the list l, preserving its original sorting.\nNote: in examples below and tests preview linked lists are presented as arrays just for simplicity of visualization: in real data you will be given a head node l of the linked list\nExample",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)\n        # check if queue is empty\n        if self.is_empty():\n            self.front = new_node\n            self.rear = new_node",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    # my code for peek method\n    def peek(self, item):\n        return self.data[-1]\n    def pop(self):\n        if len(self.data) > 0:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)\n        # set current top to new node's next\n        new_node.next = self.top\n        # reset the top pointer to the new node\n        self.top = new_node",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Stack(object):\n    def __init__(self):\n        \"\"\"Initialize an empty stack\"\"\"\n        self.items = []\n    def push(self, item):\n        \"\"\"Push a new item onto the stack\"\"\"\n        self.items.append(item)\n    def pop(self):\n        \"\"\"Remove and return the last item\"\"\"\n        # If the stack is empty, return None",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class MaxStack(object):\n    def __init__(self):\n        # Your code here\n        self.stack = Stack()\n        # self.head = []\n        self.max_stack = Stack()\n    def push(self, item):\n        \"\"\"Add a new item onto the top of our stack.\"\"\"\n        # Your code here\n        # self.head.append(item)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n        # Your code here\n        self.stack1 = Stack()\n        self.stack2 = Stack()\n    def enqueue(self, item):\n        # Your code here\n        self.stack1.push(item)\n    def dequeue(self):\n        # Your code here",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()\ndef queueOnStacks(requests):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "pivot_index",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def pivot_index(nums):\n    if len(nums) <= 1:\n        return -1\n    left = 0\n    right = sum(nums)\n    for i in range(len(nums)):\n        right -= nums[i]\n        if right == left:\n            return i\n        left += nums[i]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "plus_one",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def plus_one(digits):\n    # check the last digit if its not 9 we just add 1\n    # if it is a 9 make it 0\n    # go left check 2nd to last if its not a 9 add 1\n    # if it is a 9\n    index = len(digits) - 1\n    while index >= 0 and digits[index] == 9:\n        digits[index] = 0\n        index -= 1\n    if index == -1:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "buyAndSellStock",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):\n        # only check if the selected number minus the smallest number before",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def alphabeticShift(inputString):\n    new_string = ''\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':\n            check.append(paren)\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "delete_node",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:\n        # Copy a pointer to the next element\n        # before we overwrite current_node.next\n        next_node = current_node.next\n        # Reverse the 'next' pointer",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "insertValueIntoSortedLinkedList",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def insertValueIntoSortedLinkedList(l, value):\n    # create a new node with the value\n    node = ListNode(value)\n    # if there is no list return the new node\n    if l == None:\n        return node\n    else:\n        # else if the list.value (first item in the list) > the new value\n        if l.value > value:\n            # set new values as the first item in the list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:\n        # if either list becomes empty join lists\n        if l1 is None:\n            end.next = l2\n            break",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseNodesInKGroups",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list\n    prev = new_node\n    while True:\n        # set the start to the new node next\n        start = prev.next",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def reverse_list(start, end):\n    # set the last reversed group to the new start\n    old_reversed = start\n    # set the new current to the start\n    current = start\n    # set next node to the node start is pointing to\n    next_node = start.next\n    # while the current node is not the last node\n    while current != end:\n        # iterate",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':\n            continue\n        if paren == '(' or paren == '{' or paren == '[':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "queueOnStacks",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def queueOnStacks(requests):\n    left = Stack()\n    right = Stack()\n    def insert(x):\n        left.push(x)\n        print('queue:', left.items)\n    def remove():\n        if len(right.items) == 0:\n            while len(left.items) > 0:\n                shifted = left.pop()",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validBracketSequence",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def validBracketSequence(sequence):\n    pairs = dict(zip('(,[,{', '),],}'))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack\n# print(validBracketSequence(sequence))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n\n    for i in range(2, n):\n        # add seq at i - 2 (0 to start) and seq at i - 1 (1 to start)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "csBinarySearch",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def csBinarySearch(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[guess] < target:\n            min = guess + 1\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "csSearchRotatedSortedArray",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def csSearchRotatedSortedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        # print(f'min: {nums[min]} max: {nums[max]} guess:{nums[guess]} target:'\n        #       f' {target}')\n        # if the guess is the target we got it and return the guess\n        if nums[guess] == target:\n            # print('guessed the target')",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1\n    for idx in range(len(arr)):\n        # check if the item at the current index is equal to the target\n        if arr[i] == target:\n            # return the current index as the match\n            return i\n        i -= 1\n    # if we were able to loop through the entire array, the target is not present",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "recursive_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def recursive_search(arr, target):\n    if arr[0] == target:\n        return True\n    elif len(arr[1:]) > 1:\n        return recursive_search(arr[1:], target)\n    return False\n# print(recursive_search(arr, target))\n\"\"\"\nBinary Search\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def binary_search(arr, target):\n    # 1. Declare min = 0 and max = length of array - 1\n    min = 0\n    max = len(arr) - 1\n    while not max < min:\n        # 2. Figure out the guess value by getting the middle integer between min and max\n        guess = (max + min) // 2\n        # 3. if array[guess] equals the target, we found the element, return the index\n        if arr[guess] == target:\n            return guess",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "binary_recursive_search",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:\n        return binary_recursive_search(arr, target, guess + 1, max_index)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    min = 0\n    max = len(surnames) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        if surnames[guess] < surnames[guess + 1] and surnames[guess] < surnames[\n            guess - 1]:\n            return guess\n        else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    # UNDERSTAND\n    # [ 6,   7, 8, 0, 1, 2, 3, 4, 5]\n    #           min max\n    #           mid\n    # [ 7, 0, 1,  2, 3, 4, 5, 6]\n    #  min\n    # max\n    # mid",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "firstDraftWithTypo",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:\n        # if containsTypo(n[guess]) and not containsTypo(n[guess -1]):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "eating_cookies",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)\n    cache[0] = 1",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s\n    new_str = s[0]\n    # iterate the string\n    for letter in s:\n        # if the next letter is the same as previous continue\n        if letter == new_str[len(new_str) - 1]:\n            continue",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse_String",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***\n---------------------------",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def reverseLinkedList(l):\n    cur = l\n    prev = None\n    next = None\n    while cur:\n        next = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next\n    return prev",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkBlanagrams",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions\n        if sort1[i] != sort2[i]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "findValueSortedShiftedArray",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "def findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:\n                max = guess",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "nums = [1, 7, 3, 6, 5, 6]\n# nums = [1,2,3]\n#  O(N^2) solution\n# def pivot_index(nums):\n#     # iterate array starting at index 1\n#     # get sum of items on left of i and compare to sum of items on right of i\n#     # if they are equal return i else keep going to the next i\n#     for i in range(len(nums)):\n#         left = sum(nums[:i])\n#         right = sum(nums[i + 1:])",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "prices = [3, 100, 1, 97]\n#\n# prices = []\n# prices = [61, 91, 6, 15, 28, 30, 39, 69, 78, 81, 62, 38, 56, 69, 22, 95, 47, 82,\n#           52, 64, 74, 97, 60, 68, 5, 23, 45, 55, 66, 57, 26, 4, 21, 65, 55, 50,\n#           41, 88, 39, 84, 77, 5, 76, 11, 3, 51, 96, 100, 13, 26, 79, 98, 84, 66,\n#           93, 65, 98, 60, 57, 35, 12, 40, 83, 62, 46, 60, 26, 94, 59, 29, 70,\n#           34, 83, 98, 89, 57, 71, 44, 23, 43, 55, 1, 70, 29, 44, 10, 70, 83, 95,\n#           96, 97, 84, 23, 16, 34, 55, 59, 73, 17, 73]\n# def buyAndSellStock(prices):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "prices = [6, 3, 1, 2, 5, 4]\nprices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "prices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "prices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"crazy\"\ndef alphabeticShift(inputString):\n    new_string = ''\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "validParenthesesSequence(s) = true;\nFor s = \"()()())\", the output should be\nvalidParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "validParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "s = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "s = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == '':\n        return True\n    if s[0] == ')':\n        return False\n    for paren in s:\n        if paren == '(':\n            check.append(paren)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "x = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "y = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "z = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "x.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "y.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "x = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "y = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "z = LinkedListNode('Z')\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "x.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "y.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.\nIn order to do this in O(n) time, you should only have to traverse the list",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "max_stack",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "max_stack = MaxStack()\nmax_stack.push(1)\nmax_stack.push(2)\nmax_stack.push(5)\nmax_stack.pop()\n# print(max_stack.get_max())\n\"\"\"\nYour goal is to define a `Queue` class that uses two stacks. Your `Queue` class\nshould have an `enqueue()` method and a `dequeue()` method that ensures a\n\"first in first out\" (FIFO) order.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ ] ( ) }\"\ncode = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == '':\n        return True\n    if code[0] == ')' or code[0] == '}' or code[0] == ']':\n        return False\n    for paren in code:\n        if paren == ' ':\n            continue",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "queueOnStacks(requests)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "queueOnStacks(requests) = [1, 2].\nAfter the first request, the queue is {1}; after the second it is {1, 2}. Then we do the third request, \"pop\", and add the first element of the queue 1 to the answer array. The queue becomes {2}. After the fourth request, the queue is {2, 3}. Then we perform \"pop\" again and add 2 to the answer array, and the queue becomes {3}.\n\"\"\"\nrequests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "requests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "sequence = \"()\"\ndef validBracketSequence(sequence):\n    pairs = dict(zip('(,[,{', '),],}'))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 1 = 0 + 1 = F0 + F1.\nFor n = 11, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "2^n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "2^n = 64\nlog_2 64 = 6\nWrite an exponential expression that is identical to this logarithmic expression:\nlog_2 128 = n\n2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "2^7",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.\n\"\"\"\ndef linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case ",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "target = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case \n- the function must call itself",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "target = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "surnames = [\n    'liu',\n    'mcdowell',\n    'nixon',\n    'sparks',\n    'zhang',\n    'ahmed',  # <-- rotates here!\n    'brandt',\n    'davenport',\n    'farley',",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "surnames = [\n    'sparks',\n    'zhang',\n    'liu',\n    'ahmed',  # <-- rotates here!\n    'brandt',\n    'davenport',\n    'farley',\n    'glover',\n    'kennedy',",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "n = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndef firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "n = 3\ndef eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "removeAdjacent(s) = \"a\";\nFor s = \"abccaaab\", the output should be\nremoveAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "removeAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == '':\n        return s\n    new_str = s[0]\n    # iterate the string",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "str = 'reverse'\ndef reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = true;\nFor inputString = \"abac\", the output should be\ncheckPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList(l)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "reverseLinkedList(l) = [5, 4, 3, 2, 1].\n\"\"\"\n# Singly-linked lists are already defined with this interface:\n# class ListNode(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.next = None\n#\ndef reverseLinkedList(l):\n    cur = l",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "word1",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "word1 = \"tangpam\"\nword2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "word2",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "word2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == '' or word2 == '':\n        return False\n    work_string = ''\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "nums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks3-4-projects",
        "description": ".gitbook.assets.cs-weeks3-4-projects",
        "peekOfCode": "target = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:",
        "detail": ".gitbook.assets.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "BSTNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BSTNode(value)\n            else:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class BST:\n    def __init__(self, value):\n        self.root = BSTNode(value)\n    def insert(self, value):\n        return self.root.insert(value)\n    def search(self, target):\n        return self.root.search(target)\n    def find_minimum_value(self):\n        return self.root.find_minimum_value().value\n    def delete(self, value):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n# go all the way down to left then back to root then right in iterative or\n# recursive\n# for recursive solution keep track of base case (when there is no root) and\n# the recursive way\ndef inorder_traversal(root):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n            'A': {'B': 1},\n            'B': {'C': 3, 'D': 2, 'E': 1},\n            'C': {'E': 4},\n            'D': {'E': 2},\n            'E': {'F': 3},\n            'F': {},\n            'G': {'D': 1},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.edges = [\n            [0, 1, 0, 0, 0, 0, 0],\n            [0, 0, 3, 3, 1, 0, 0],\n            [0, 0, 0, 0, 4, 0, 0],\n            [0, 0, 0, 0, 2, 0, 0],\n            [0, 0, 0, 0, 0, 3, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 1, 0, 0, 0],",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Vertex:\n    def __init__(self, value):\n        self.value = value\n        self.connections = {}\n    def __str__(self):\n        return str(self.value) + ' connections: ' + str(\n            [x.value for x in self.connections])\n    def add_connection(self, vert, weight=0):\n        self.connections[vert] = weight\n    def get_connections(self):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.count = 0\n    def __contains__(self, vert):\n        return vert in self.vertices\n    def __iter__(self):\n        return iter(self.vertices.values())\n    def add_vertex(self, value):\n        self.count += 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "GraphNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class GraphNode:\n    def __init__(self, label):\n        self.label = label\n        self.neighbors = set()\n        self.color = None\ndef color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "class Solution:\n    def isCompleteTree(self, root: TreeNode) -> bool:\n        # we want to check each node for a right child\n        # if a right child exists and no left child exists we can return false\n        # if the left subtree is missing one or both children where the right\n        # subtree at that level has children return false\n        # init case where a node has no right child\n        no_right_child = False\n        # init case where a node has no children\n        no_children = False",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "maxDepth",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively\n    # calling maxDepth on each side of the subtree\n    left_depth = self.maxDepth(root.left)\n    right_depth = self.maxDepth(root.right)\n    # if the left depth is greater than the right depth return the left depth\n    # plus 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "is_valid_BST",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid\n    else:\n        if root.left is None and root.right is None:\n            return True\n        elif root.left is None:\n            if root.right > root:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "balancedBinaryTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def balancedBinaryTree(root):\n    # define method to get the height of the tree\n    def get_height(root):\n        if root is None:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1\n    # if the root is None return True\n    if root is None:\n        return True\n    # get the heights of each subtree",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "minimumDepthBinaryTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def minimumDepthBinaryTree(root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root has no children return 1\n    if root.left is None and root.right is None:\n        return 1\n    # if no left child traverse the right tree\n    if root.left is None:\n        return minimumDepthBinaryTree(root.right) + 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)\n    helper(root.right, res)\ndef inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first pre-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)\n    helper(root.right, res)\ndef preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "preorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first  first post-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)\n    res.append(root.val)\ndef postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "postorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nBreadth first level order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "breadth_first_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)\n        result.append(node.val)\n        if node.left is not None:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def inorder_traversal(root):\n    # base case\n    if root is None:\n        return []\n    # recursively call the function on the left child until no more left\n    # children then the root will be none and the values are returned up the\n    # chain inorder\n    return inorder_traversal(root.left) + [root.val] + inorder_traversal(\n        root.right)\n# the iterative way with a stack",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "build_tree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree\n    # all items to the right of inorder[root] will be the right subtree\n    # pick the next element in preorder starting with item[0]\n    # create a new node with val set to the element\n    # delete it from preorder\n    # get the index of that element from inorder list using hashMaps to",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "binaryTreeInOrderTraversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def binaryTreeInOrderTraversal(root):\n    stack = []\n    result = []\n    while root is not None or stack != []:\n        while root is not None:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.value)\n        root = root.right",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "traverseTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def traverseTree(t):\n    queue = []\n    result = []\n    if t is None:\n        return result\n    root = t\n    queue.append(root)\n    while len(queue) > 0:\n        root = queue.pop(0)\n        result.append(root.value)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "treePaths",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def treePaths(t):\n    if t is None:\n        return []\n    result, stack = [], [(t, '')]\n    while stack:\n        root, el = stack.pop()\n        if root.left is None and root.right is None:\n            result.append(el + str(root.value))\n        if root.right:\n            stack.append((root.right, el + str(root.value) + '->'))",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "color_graph",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass\n\"\"\"\n*** Demo 2 ***\n--------------\nYou are given a 2d grid of `\"1\"`s and `\"0\"`s that represents a \"map\". The\n`\"1\"`s represent land and the `\"0\"s` represent water.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "numIslands",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"\n*** Code signal ***\n-------------------\nYou are given a directed acyclic graph (DAG) that contains N nodes.\nWrite a function that can find all the possible paths from node 0 to node N - 1. You can return the path in any order.\ngraph[a] is a list of all nodes b for which the edge a -> b exists.\nExample:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):\n            if v_from in self.verts and v_to in self.verts:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def floodfill(image, row, col, color):\n    if image[row][col] != ' ':\n        return\n    image[row][col] = color\n    floodfill(row, col + 1, color)\n    floodfill(row, col - 1, color)\n    floodfill(row + 1, col, color)\n    floodfill(row - 1, col, color)\n\"\"\"\nDemo 2",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "find_judge",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def find_judge(N, trust):\n    \"\"\"\n    Inputs:\n    N -> int\n    trust -> List[List[int]]\n    Output:\n    int\n    \"\"\"\n    # Your code here\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "csFriendCircles",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "get_neighbors",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):\n            diff = 0\n            for i in range(len(w)):\n                if w[i] != word[i]:\n                    diff += 1\n                if diff > 1:\n                    break",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def bfs(start_word, end_word):\n    print('s, e', start_word, end_word)\n    visited = set()\n    q = [[start_word]]\n    while q:\n        path = q.pop(0)\n        v = path[-1]\n        if v not in visited:\n            visited.add(v)\n            if v == end_word:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "csBSTRangeSum",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def csBSTRangeSum(root, lower, upper):\n    # variable to hold running sum of target numbers\n    range = []\n    # variable to hold the current node\n    cur = root\n    # search the tree to find all numbers within the range of lower and upper\n    # dfs\n    def helper(root):\n        if root is None:\n            return",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "csBinaryTreeInvert",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def csBinaryTreeInvert(root):\n    # use a bft to visit all levels and switch the positions of left and\n    # right children for each node at each level\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "reversePairs",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "def reversePairs(nums):\n    # EDGE CASE if the array length is less than 2 return 0\n    if len(nums) < 2:\n        return 0\n    # init i to 0 and j to 1\n    i = 0\n    j = 1\n    # init count for reverse pairs found\n    count = 0\n    # iterate the array",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "log2(128)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "log2(128) = h\n2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "2**7",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "n = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "n = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "n = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "n = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "preorder = [5,7,22,13,9]\ninorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "inorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first\n--- Traverse the left subtree in preorder",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "preorder = [5, 7, 22, 13, 9]\ninorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "inorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "tree = build_tree(preorder, inorder)\n# print('tree:', inorder_traversal(tree))\n\"\"\"\n*** CodeSignal ***\n------------------\n\"\"\"\n\"\"\"\nYou are given a binary tree. Write a function that returns the binary tree's node values using an in-order traversal.\nExample:\nInput: [2,None,3,4]",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": null,\n        \"right\": {\n            \"value\": 3,\n            \"left\": null,\n            \"right\": null\n        }",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "traverseTree(t)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "traverseTree(t) = [1, 2, 4, 3, 5].\nThis t looks like this:\n     1\n   /   \\\n  2     4\n   \\   /\n    3 5\n\"\"\"\nt = {\n    \"value\": 1,",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": None,\n        \"right\": {\n            \"value\": 3,\n            \"left\": None,\n            \"right\": None\n        }",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "t = {\n    \"value\": 5,\n    \"left\": {\n        \"value\": 2,\n        \"left\": {\n            \"value\": 10,\n            \"left\": null,\n            \"right\": null\n        },\n        \"right\": {",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "treePaths(t)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "treePaths(t) = [\"5->2->10\", \"5->2->4\", \"5->-3\"].\nThe given tree looks like this:\n    5\n   / \\\n  2  -3\n / \\\n10  4\n\"\"\"\n#\n# Binary trees are already defined with this interface:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "g_verts",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "g_verts = ['A', 'B', 'C', 'D', 'E']\ng = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge('A', 'B', 1)\ng.add_edge('B', 'C', 3)\ng.add_edge('B', 'D', 2)\ng.add_edge('E', 'D', 1)\n# for v in g:\n#     for w in v.get_connections():",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "g = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge('A', 'B', 1)\ng.add_edge('B', 'C', 3)\ng.add_edge('B', 'D', 2)\ng.add_edge('E', 'D', 1)\n# for v in g:\n#     for w in v.get_connections():\n#         print(\"( %s, %s )\" % (v.get_value(), w.get_value()))",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "grid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"]\n]\ndef numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "graph = [[1, 2], [3], [3], [4], []]\ndef csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "image = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "sr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "sr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```\nNotes:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "friendships = [[1, 1, 0],\n               [1, 1, 0],\n               [0, 0, 1]]\nfriendships = [[1, 1, 0],\n               [1, 1, 1],\n               [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "friendships = [[1, 1, 0],\n               [1, 1, 1],\n               [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "start_word",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "start_word = 'hit'\nend_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "end_word",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "end_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "words = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "root = [10, 5, 15, 3, 7, null, 18]\nlower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "lower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "upper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:\nInput:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "root = [10,5,15,3,7,13,18,1,null,6]\nlower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "lower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "upper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:\n23",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "root = [10, 5, 15, 3, 7, None, 18]\nlower = 7\nupper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "lower = 7\nupper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n#",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "upper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n#\n# Binary trees are already defined with this interface:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "description": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "peekOfCode": "nums = [1, 3, 2, 3, 1]\nprint(f'reversePairs(nums): {reversePairs(nums)}')\n\"\"\"\n958. Check Completeness of a Binary Tree\nMedium\n1072\n14\nAdd to List\nShare\nGiven the root of a binary tree, determine if it is a complete binary tree.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects (1)",
        "documentation": {}
    },
    {
        "label": "BSTNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BSTNode(value)\n            else:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class BST:\n    def __init__(self, value):\n        self.root = BSTNode(value)\n    def insert(self, value):\n        return self.root.insert(value)\n    def search(self, target):\n        return self.root.search(target)\n    def find_minimum_value(self):\n        return self.root.find_minimum_value().value\n    def delete(self, value):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n# go all the way down to left then back to root then right in iterative or\n# recursive\n# for recursive solution keep track of base case (when there is no root) and\n# the recursive way\ndef inorder_traversal(root):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n            'A': {'B': 1},\n            'B': {'C': 3, 'D': 2, 'E': 1},\n            'C': {'E': 4},\n            'D': {'E': 2},\n            'E': {'F': 3},\n            'F': {},\n            'G': {'D': 1},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.edges = [\n            [0, 1, 0, 0, 0, 0, 0],\n            [0, 0, 3, 3, 1, 0, 0],\n            [0, 0, 0, 0, 4, 0, 0],\n            [0, 0, 0, 0, 2, 0, 0],\n            [0, 0, 0, 0, 0, 3, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 1, 0, 0, 0],",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Vertex:\n    def __init__(self, value):\n        self.value = value\n        self.connections = {}\n    def __str__(self):\n        return str(self.value) + ' connections: ' + str(\n            [x.value for x in self.connections])\n    def add_connection(self, vert, weight=0):\n        self.connections[vert] = weight\n    def get_connections(self):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.count = 0\n    def __contains__(self, vert):\n        return vert in self.vertices\n    def __iter__(self):\n        return iter(self.vertices.values())\n    def add_vertex(self, value):\n        self.count += 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "GraphNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class GraphNode:\n    def __init__(self, label):\n        self.label = label\n        self.neighbors = set()\n        self.color = None\ndef color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "class Solution:\n    def isCompleteTree(self, root: TreeNode) -> bool:\n        # we want to check each node for a right child\n        # if a right child exists and no left child exists we can return false\n        # if the left subtree is missing one or both children where the right\n        # subtree at that level has children return false\n        # init case where a node has no right child\n        no_right_child = False\n        # init case where a node has no children\n        no_children = False",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "maxDepth",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively\n    # calling maxDepth on each side of the subtree\n    left_depth = self.maxDepth(root.left)\n    right_depth = self.maxDepth(root.right)\n    # if the left depth is greater than the right depth return the left depth\n    # plus 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "is_valid_BST",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid\n    else:\n        if root.left is None and root.right is None:\n            return True\n        elif root.left is None:\n            if root.right > root:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "balancedBinaryTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def balancedBinaryTree(root):\n    # define method to get the height of the tree\n    def get_height(root):\n        if root is None:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1\n    # if the root is None return True\n    if root is None:\n        return True\n    # get the heights of each subtree",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "minimumDepthBinaryTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def minimumDepthBinaryTree(root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root has no children return 1\n    if root.left is None and root.right is None:\n        return 1\n    # if no left child traverse the right tree\n    if root.left is None:\n        return minimumDepthBinaryTree(root.right) + 1",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)\n    helper(root.right, res)\ndef inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first pre-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)\n    helper(root.right, res)\ndef preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first  first post-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)\n    res.append(root.val)\ndef postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "postorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nBreadth first level order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "breadth_first_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)\n        result.append(node.val)\n        if node.left is not None:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def inorder_traversal(root):\n    # base case\n    if root is None:\n        return []\n    # recursively call the function on the left child until no more left\n    # children then the root will be none and the values are returned up the\n    # chain inorder\n    return inorder_traversal(root.left) + [root.val] + inorder_traversal(\n        root.right)\n# the iterative way with a stack",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "build_tree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree\n    # all items to the right of inorder[root] will be the right subtree\n    # pick the next element in preorder starting with item[0]\n    # create a new node with val set to the element\n    # delete it from preorder\n    # get the index of that element from inorder list using hashMaps to",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "binaryTreeInOrderTraversal",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def binaryTreeInOrderTraversal(root):\n    stack = []\n    result = []\n    while root is not None or stack != []:\n        while root is not None:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.value)\n        root = root.right",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "traverseTree",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def traverseTree(t):\n    queue = []\n    result = []\n    if t is None:\n        return result\n    root = t\n    queue.append(root)\n    while len(queue) > 0:\n        root = queue.pop(0)\n        result.append(root.value)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "treePaths",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def treePaths(t):\n    if t is None:\n        return []\n    result, stack = [], [(t, '')]\n    while stack:\n        root, el = stack.pop()\n        if root.left is None and root.right is None:\n            result.append(el + str(root.value))\n        if root.right:\n            stack.append((root.right, el + str(root.value) + '->'))",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "color_graph",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass\n\"\"\"\n*** Demo 2 ***\n--------------\nYou are given a 2d grid of `\"1\"`s and `\"0\"`s that represents a \"map\". The\n`\"1\"`s represent land and the `\"0\"s` represent water.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "numIslands",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"\n*** Code signal ***\n-------------------\nYou are given a directed acyclic graph (DAG) that contains N nodes.\nWrite a function that can find all the possible paths from node 0 to node N - 1. You can return the path in any order.\ngraph[a] is a list of all nodes b for which the edge a -> b exists.\nExample:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):\n            if v_from in self.verts and v_to in self.verts:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def floodfill(image, row, col, color):\n    if image[row][col] != ' ':\n        return\n    image[row][col] = color\n    floodfill(row, col + 1, color)\n    floodfill(row, col - 1, color)\n    floodfill(row + 1, col, color)\n    floodfill(row - 1, col, color)\n\"\"\"\nDemo 2",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "find_judge",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def find_judge(N, trust):\n    \"\"\"\n    Inputs:\n    N -> int\n    trust -> List[List[int]]\n    Output:\n    int\n    \"\"\"\n    # Your code here\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csFriendCircles",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "get_neighbors",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):\n            diff = 0\n            for i in range(len(w)):\n                if w[i] != word[i]:\n                    diff += 1\n                if diff > 1:\n                    break",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def bfs(start_word, end_word):\n    print('s, e', start_word, end_word)\n    visited = set()\n    q = [[start_word]]\n    while q:\n        path = q.pop(0)\n        v = path[-1]\n        if v not in visited:\n            visited.add(v)\n            if v == end_word:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csBSTRangeSum",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def csBSTRangeSum(root, lower, upper):\n    # variable to hold running sum of target numbers\n    range = []\n    # variable to hold the current node\n    cur = root\n    # search the tree to find all numbers within the range of lower and upper\n    # dfs\n    def helper(root):\n        if root is None:\n            return",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csBinaryTreeInvert",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def csBinaryTreeInvert(root):\n    # use a bft to visit all levels and switch the positions of left and\n    # right children for each node at each level\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "reversePairs",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "def reversePairs(nums):\n    # EDGE CASE if the array length is less than 2 return 0\n    if len(nums) < 2:\n        return 0\n    # init i to 0 and j to 1\n    i = 0\n    j = 1\n    # init count for reverse pairs found\n    count = 0\n    # iterate the array",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "log2(128)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "log2(128) = h\n2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "2**7",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "n = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "n = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "n = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "n = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "preorder = [5,7,22,13,9]\ninorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "inorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first\n--- Traverse the left subtree in preorder",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "preorder = [5, 7, 22, 13, 9]\ninorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "inorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "tree = build_tree(preorder, inorder)\n# print('tree:', inorder_traversal(tree))\n\"\"\"\n*** CodeSignal ***\n------------------\n\"\"\"\n\"\"\"\nYou are given a binary tree. Write a function that returns the binary tree's node values using an in-order traversal.\nExample:\nInput: [2,None,3,4]",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": null,\n        \"right\": {\n            \"value\": 3,\n            \"left\": null,\n            \"right\": null\n        }",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "traverseTree(t)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "traverseTree(t) = [1, 2, 4, 3, 5].\nThis t looks like this:\n     1\n   /   \\\n  2     4\n   \\   /\n    3 5\n\"\"\"\nt = {\n    \"value\": 1,",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": None,\n        \"right\": {\n            \"value\": 3,\n            \"left\": None,\n            \"right\": None\n        }",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 5,\n    \"left\": {\n        \"value\": 2,\n        \"left\": {\n            \"value\": 10,\n            \"left\": null,\n            \"right\": null\n        },\n        \"right\": {",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "treePaths(t)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "treePaths(t) = [\"5->2->10\", \"5->2->4\", \"5->-3\"].\nThe given tree looks like this:\n    5\n   / \\\n  2  -3\n / \\\n10  4\n\"\"\"\n#\n# Binary trees are already defined with this interface:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "g_verts",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "g_verts = ['A', 'B', 'C', 'D', 'E']\ng = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge('A', 'B', 1)\ng.add_edge('B', 'C', 3)\ng.add_edge('B', 'D', 2)\ng.add_edge('E', 'D', 1)\n# for v in g:\n#     for w in v.get_connections():",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "g = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge('A', 'B', 1)\ng.add_edge('B', 'C', 3)\ng.add_edge('B', 'D', 2)\ng.add_edge('E', 'D', 1)\n# for v in g:\n#     for w in v.get_connections():\n#         print(\"( %s, %s )\" % (v.get_value(), w.get_value()))",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "grid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"]\n]\ndef numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "graph = [[1, 2], [3], [3], [4], []]\ndef csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "image = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "sr",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "sr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```\nNotes:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "friendships = [[1, 1, 0],\n               [1, 1, 0],\n               [0, 0, 1]]\nfriendships = [[1, 1, 0],\n               [1, 1, 1],\n               [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "friendships = [[1, 1, 0],\n               [1, 1, 1],\n               [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "start_word",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "start_word = 'hit'\nend_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "end_word",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "end_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "words = set()\nwith open('words.txt') as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "root = [10, 5, 15, 3, 7, null, 18]\nlower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "lower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "upper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:\nInput:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "root = [10,5,15,3,7,13,18,1,null,6]\nlower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "lower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "upper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:\n23",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "root = [10, 5, 15, 3, 7, None, 18]\nlower = 7\nupper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "lower = 7\nupper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n#",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "upper = 15\n#\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n#\n# Binary trees are already defined with this interface:",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks5-6-projects",
        "description": ".gitbook.assets.cs-weeks5-6-projects",
        "peekOfCode": "nums = [1, 3, 2, 3, 1]\nprint(f'reversePairs(nums): {reversePairs(nums)}')\n\"\"\"\n958. Check Completeness of a Binary Tree\nMedium\n1072\n14\nAdd to List\nShare\nGiven the root of a binary tree, determine if it is a complete binary tree.",
        "detail": ".gitbook.assets.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "class ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\nclass MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "class MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size\n        self.values = [None] * self.size\n        self.item_count = 0\n    def djb2(self, key):\n        str_key = str(key).encode()\n        hash_value = 5381",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "are_words_sorted",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here\n    # map the letters of the string alpha_order to a dictionary",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csFindTheSingleNumber",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1\n    # return the key with the value of 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csAverageOfTopFive",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csAverageOfTopFive(scores):\n    students_scores = {}\n    # create a dict with each student as the key and an array of their scores\n    # as the value\n    for score in scores:\n        student = score[0]\n        num = score[1]\n        if student in students_scores:\n            students_scores[student].append(num)\n        else:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csMaxNumberOfLambdas",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:\n        if letter in lambdas:\n            lambdas[letter] += 1\n    minimum_letter = lambdas['l']",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies\n    word_freqs = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "frequency_sort",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:\n        if char not in letter_freq:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csIsomorphicStrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.\nHere, to \"follow\" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in s.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csWordPattern",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_map:\n            if word_arr[i] not in pattern_map.values():\n                pattern_map[pattern[i]] = word_arr[i]\n            else:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "csGroupAnagrams",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:\n        all_results.append(result[item])",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def condense_linked_list(node):\n    # keep track of seen values\n    seen_values = []\n    cur = node\n    prev = None\n    # iterate linked list from the head\n    while cur is not None:\n        print(cur.value)\n        # if current is in seen values\n        if cur.value in seen_values:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1\n    for key in chars:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "uncover_spy",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "def uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:\n        if group[0] in trusts:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "hash_table = MyHashTable();\nhash_table.put(\"a\", 1);\nhash_table.put(\"b\", 2);\nhash_table.get(\"a\");            // returns 1\nhash_table.get(\"c\");            // returns -1 (not found)\nhash_table.put(\"b\", 1);         // update the existing value\nhash_table.get(\"b\");            // returns 1\nhash_table.remove(\"b\");         // remove the mapping for 2\nhash_table.get(\"b\");            // returns -1 (not found)\n```",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "words = [\"lambd\", \"school\"]\norder = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "order",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "nums = [1, 1, 2, 1]\ndef csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "scores",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "scores = [[1, 91], [1, 92], [2, 93], [2, 97], [1, 60], [2, 77], [1, 65],\n          [1, 87], [1, 100], [2, 100], [2, 76]]\ndef csAverageOfTopFive(scores):\n    students_scores = {}\n    # create a dict with each student as the key and an array of their scores\n    # as the value\n    for score in scores:\n        student = score[0]\n        num = score[1]\n        if student in students_scores:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "text = \"mbxcdatllaas\"\n# text = \"sctlamb\"\n# text = \"lalaaxcmbdtsumbdav\"\ndef csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\",\n         \"is\"]\nk = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "k = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "k = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "s = \"Bbcc\"\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "b = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "b = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "b = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "b = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "b = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "pattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "a = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "strs = [\"apt\",\"pat\",\"ear\",\"tap\",\"are\",\"arm\"]\nOutput:\n[[\"apt\",\"pat\",\"tap\"],[\"ear\",\"are\"],[\"arm\"]]\nExample 2:\nInput:\nstrs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "strs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:\nstrs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "strs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "strs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "first_not_repeating_character(s) = 'c'.\nThere are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.\nFor s = \"abacabaabacaba\", the output should be\nfirst_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "first_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.\n\"\"\"\ns = \"abacabad\"\ndef first_not_repeating_character(s):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "s = \"abacabad\"\ndef first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "n = 3\ntrust = [[1,2],\n [2,3]]\nn = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "trust = [[1,2],\n [2,3]]\nn = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "n = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "description": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "peekOfCode": "trust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects (1)",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "class ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\nclass MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "kind": 6,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "class MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size\n        self.values = [None] * self.size\n        self.item_count = 0\n    def djb2(self, key):\n        str_key = str(key).encode()\n        hash_value = 5381",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "are_words_sorted",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here\n    # map the letters of the string alpha_order to a dictionary",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csFindTheSingleNumber",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1\n    # return the key with the value of 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csAverageOfTopFive",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csAverageOfTopFive(scores):\n    students_scores = {}\n    # create a dict with each student as the key and an array of their scores\n    # as the value\n    for score in scores:\n        student = score[0]\n        num = score[1]\n        if student in students_scores:\n            students_scores[student].append(num)\n        else:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csMaxNumberOfLambdas",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:\n        if letter in lambdas:\n            lambdas[letter] += 1\n    minimum_letter = lambdas['l']",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies\n    word_freqs = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "frequency_sort",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:\n        if char not in letter_freq:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csIsomorphicStrings",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.\nHere, to \"follow\" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in s.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csWordPattern",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_map:\n            if word_arr[i] not in pattern_map.values():\n                pattern_map[pattern[i]] = word_arr[i]\n            else:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csGroupAnagrams",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:\n        all_results.append(result[item])",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def condense_linked_list(node):\n    # keep track of seen values\n    seen_values = []\n    cur = node\n    prev = None\n    # iterate linked list from the head\n    while cur is not None:\n        print(cur.value)\n        # if current is in seen values\n        if cur.value in seen_values:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1\n    for key in chars:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "uncover_spy",
        "kind": 2,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "def uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:\n        if group[0] in trusts:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "hash_table = MyHashTable();\nhash_table.put(\"a\", 1);\nhash_table.put(\"b\", 2);\nhash_table.get(\"a\");            // returns 1\nhash_table.get(\"c\");            // returns -1 (not found)\nhash_table.put(\"b\", 1);         // update the existing value\nhash_table.get(\"b\");            // returns 1\nhash_table.remove(\"b\");         // remove the mapping for 2\nhash_table.get(\"b\");            // returns -1 (not found)\n```",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambd\", \"school\"]\norder = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "order",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "nums = [1, 1, 2, 1]\ndef csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "scores",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "scores = [[1, 91], [1, 92], [2, 93], [2, 97], [1, 60], [2, 77], [1, 65],\n          [1, 87], [1, 100], [2, 100], [2, 76]]\ndef csAverageOfTopFive(scores):\n    students_scores = {}\n    # create a dict with each student as the key and an array of their scores\n    # as the value\n    for score in scores:\n        student = score[0]\n        num = score[1]\n        if student in students_scores:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "text = \"mbxcdatllaas\"\n# text = \"sctlamb\"\n# text = \"lalaaxcmbdtsumbdav\"\ndef csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\",\n         \"is\"]\nk = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "k = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "k = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "s = \"Bbcc\"\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "b = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "b = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "b = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "b = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "b = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(' ')\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"apt\",\"pat\",\"ear\",\"tap\",\"are\",\"arm\"]\nOutput:\n[[\"apt\",\"pat\",\"tap\"],[\"ear\",\"are\"],[\"arm\"]]\nExample 2:\nInput:\nstrs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:\nstrs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = ''.join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "first_not_repeating_character(s) = 'c'.\nThere are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.\nFor s = \"abacabaabacaba\", the output should be\nfirst_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "first_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.\n\"\"\"\ns = \"abacabad\"\ndef first_not_repeating_character(s):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "s = \"abacabad\"\ndef first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "n = 3\ntrust = [[1,2],\n [2,3]]\nn = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "trust = [[1,2],\n [2,3]]\nn = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "n = 4\ntrust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": ".gitbook.assets.cs-weeks7-8-projects",
        "description": ".gitbook.assets.cs-weeks7-8-projects",
        "peekOfCode": "trust = [[1, 3],[1, 4],[2, 3],[2, 4],[4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:",
        "detail": ".gitbook.assets.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "dfs_components_grid",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_components_grid",
        "description": ".gitbook.assets.dfs_components_grid",
        "peekOfCode": "def dfs_components_grid(grid: Sequence[Sequence[int]]) -> Iterable[set[tuple[int, int]]]:\n    \"\"\"On a grid of 0s and 1s, find all the components of 1s.\"\"\"\n    unseen = {(r, c) for r, row in enumerate(grid) for c, n in enumerate(row) if n}\n    while unseen:\n        start = unseen.pop()\n        component = {start}\n        to_visit = [start]\n        while to_visit:\n            r, c = to_visit.pop()\n            adjacent = {(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)}",
        "detail": ".gitbook.assets.dfs_components_grid",
        "documentation": {}
    },
    {
        "label": "dfs_component_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_component_dict (1)",
        "description": ".gitbook.assets.dfs_component_dict (1)",
        "peekOfCode": "def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:\n    \"\"\"Find all the nodes connected to the starting node, using DFS on a dict.\"\"\"\n    component = {start}\n    to_visit = [start]\n    while to_visit:\n        node = to_visit.pop()\n        new_nodes = graph[node] - component\n        to_visit.extend(new_nodes)\n        component |= new_nodes\n        yield node",
        "detail": ".gitbook.assets.dfs_component_dict (1)",
        "documentation": {}
    },
    {
        "label": "dfs_component_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_component_dict (2)",
        "description": ".gitbook.assets.dfs_component_dict (2)",
        "peekOfCode": "def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:\n    \"\"\"Find all the nodes connected to the starting node, using DFS on a dict.\"\"\"\n    component = {start}\n    to_visit = [start]\n    while to_visit:\n        node = to_visit.pop()\n        new_nodes = graph[node] - component\n        to_visit.extend(new_nodes)\n        component |= new_nodes\n        yield node",
        "detail": ".gitbook.assets.dfs_component_dict (2)",
        "documentation": {}
    },
    {
        "label": "dfs_component_dict",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_component_dict",
        "description": ".gitbook.assets.dfs_component_dict",
        "peekOfCode": "def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:\n    \"\"\"Find all the nodes connected to the starting node, using DFS on a dict.\"\"\"\n    component = {start}\n    to_visit = [start]\n    while to_visit:\n        node = to_visit.pop()\n        new_nodes = graph[node] - component\n        to_visit.extend(new_nodes)\n        component |= new_nodes\n        yield node",
        "detail": ".gitbook.assets.dfs_component_dict",
        "documentation": {}
    },
    {
        "label": "dfs_component_dict_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_component_dict_recur (1)",
        "description": ".gitbook.assets.dfs_component_dict_recur (1)",
        "peekOfCode": "def dfs_component_dict_recur(\n    graph: Mapping[Node, Set[Node]],\n    start: Node,\n    component: Optional[Set[Node]] = None\n) -> set[Node]:\n    \"\"\"Recursively find all the nodes connected to start.\"\"\"\n    if component is None:\n        component = set()\n    component.add(start)\n    for new_node in graph[start] - component:",
        "detail": ".gitbook.assets.dfs_component_dict_recur (1)",
        "documentation": {}
    },
    {
        "label": "dfs_component_dict_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_component_dict_recur",
        "description": ".gitbook.assets.dfs_component_dict_recur",
        "peekOfCode": "def dfs_component_dict_recur(\n    graph: Mapping[Node, Set[Node]],\n    start: Node,\n    component: Optional[Set[Node]] = None\n) -> set[Node]:\n    \"\"\"Recursively find all the nodes connected to start.\"\"\"\n    if component is None:\n        component = set()\n    component.add(start)\n    for new_node in graph[start] - component:",
        "detail": ".gitbook.assets.dfs_component_dict_recur",
        "documentation": {}
    },
    {
        "label": "dfs_paths_dict_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.dfs_paths_dict_recur",
        "description": ".gitbook.assets.dfs_paths_dict_recur",
        "peekOfCode": "def dfs_paths_dict_recur(\n    graph: Mapping[Node, set[Node]],\n    start: Node,\n    goal: Node,\n    path: Optional[list[Node]] = None\n) -> Iterable[list[Node]]:\n    \"\"\"Find all the paths from start to goal recursively on a dict.\"\"\"\n    if path is None:\n        path = [start]\n    if start == goal:",
        "detail": ".gitbook.assets.dfs_paths_dict_recur",
        "documentation": {}
    },
    {
        "label": "dijkstras_distances_min",
        "kind": 2,
        "importPath": ".gitbook.assets.dijkstras_distances_min (1)",
        "description": ".gitbook.assets.dijkstras_distances_min (1)",
        "peekOfCode": "def dijkstras_distances_min(graph: Mapping[Node, Mapping[Node, Rational]], start: Node) -> dict[Node: Rational]:\n    \"\"\"Find the minimum distance from start to all connected nodes on a directed, weighted graph.\"\"\"\n    distances = dict.fromkeys(graph, inf)\n    distances[start] = 0\n    unvisited = set(graph)\n    while unvisited:\n        # Using min like this increases the time complexity compared to a priority queue, but it simplifies things.\n        node = min(unvisited, key=distances.__getitem__)\n        unvisited.remove(node)\n        distance = distances[node]",
        "detail": ".gitbook.assets.dijkstras_distances_min (1)",
        "documentation": {}
    },
    {
        "label": "dijkstras_distances_min",
        "kind": 2,
        "importPath": ".gitbook.assets.dijkstras_distances_min",
        "description": ".gitbook.assets.dijkstras_distances_min",
        "peekOfCode": "def dijkstras_distances_min(graph: Mapping[Node, Mapping[Node, Rational]], start: Node) -> dict[Node: Rational]:\n    \"\"\"Find the minimum distance from start to all connected nodes on a directed, weighted graph.\"\"\"\n    distances = dict.fromkeys(graph, inf)\n    distances[start] = 0\n    unvisited = set(graph)\n    while unvisited:\n        # Using min like this increases the time complexity compared to a priority queue, but it simplifies things.\n        node = min(unvisited, key=distances.__getitem__)\n        unvisited.remove(node)\n        distance = distances[node]",
        "detail": ".gitbook.assets.dijkstras_distances_min",
        "documentation": {}
    },
    {
        "label": "dijkstras_path_pq",
        "kind": 2,
        "importPath": ".gitbook.assets.dijkstras_path_pq (1)",
        "description": ".gitbook.assets.dijkstras_path_pq (1)",
        "peekOfCode": "def dijkstras_path_pq(\n    graph: Mapping[Node, Mapping[Node, Real]],\n    start: Node,\n    goal: Node\n) -> dict[Node, Optional[Node]]:\n    \"\"\"Find the shortest path from start to goal in a directed, weighted graph. Return it as a parents dict.\"\"\"\n    distances = {start: 0}\n    parents = {start: None}\n    visited = set()\n    to_visit = [(0, start)]",
        "detail": ".gitbook.assets.dijkstras_path_pq (1)",
        "documentation": {}
    },
    {
        "label": "dijkstras_path_pq",
        "kind": 2,
        "importPath": ".gitbook.assets.dijkstras_path_pq",
        "description": ".gitbook.assets.dijkstras_path_pq",
        "peekOfCode": "def dijkstras_path_pq(\n    graph: Mapping[Node, Mapping[Node, Real]],\n    start: Node,\n    goal: Node\n) -> dict[Node, Optional[Node]]:\n    \"\"\"Find the shortest path from start to goal in a directed, weighted graph. Return it as a parents dict.\"\"\"\n    distances = {start: 0}\n    parents = {start: None}\n    visited = set()\n    to_visit = [(0, start)]",
        "detail": ".gitbook.assets.dijkstras_path_pq",
        "documentation": {}
    },
    {
        "label": "Employee",
        "kind": 6,
        "importPath": ".gitbook.assets.employees",
        "description": ".gitbook.assets.employees",
        "peekOfCode": "class Employee(object):\n    def __init__(self, first_name, last_name, job):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.job = job\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            same_name = self.first_name == other.first_name and self.last_name == other.last_name\n            same_job = self.job == other.job\n            if same_name and same_job:",
        "detail": ".gitbook.assets.employees",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": ".gitbook.assets.employees",
        "description": ".gitbook.assets.employees",
        "peekOfCode": "class Job(object):\n    def __init__(self, title, salary):\n        self.title = title\n        self.salary = salary\n    def __str__(self):\n        print(self.title)\n    def __repr__(self):\n        return 'Job(title={}, salary={})'.format(self.title, self.salary)\ndef sort_employees_by_salary(employee_list):\n    \"\"\"",
        "detail": ".gitbook.assets.employees",
        "documentation": {}
    },
    {
        "label": "sort_employees_by_salary",
        "kind": 2,
        "importPath": ".gitbook.assets.employees",
        "description": ".gitbook.assets.employees",
        "peekOfCode": "def sort_employees_by_salary(employee_list):\n    \"\"\"\n    Returns a new employee list, sorted by low to high salary then last_name\n    \"\"\"\n    employee_list.sort(key=lambda employee: (employee.last_name, employee.job.salary))\n    return employee_list",
        "detail": ".gitbook.assets.employees",
        "documentation": {}
    },
    {
        "label": "josephus_problem_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.josephus_problem_recur",
        "description": ".gitbook.assets.josephus_problem_recur",
        "peekOfCode": "def josephus_problem_recur(n: int, k: int) -> int:\n    \"\"\"1-indexed, k-skips, Josephus problem, recursively.\"\"\"\n    if n == 1:\n        return 1\n    return (josephus_problem_recur(n - 1, k) + k - 1) % n + 1",
        "detail": ".gitbook.assets.josephus_problem_recur",
        "documentation": {}
    },
    {
        "label": "knapsack_simple",
        "kind": 2,
        "importPath": ".gitbook.assets.knapsack_simple",
        "description": ".gitbook.assets.knapsack_simple",
        "peekOfCode": "def knapsack_simple(weights: Sequence[int], values: Sequence[int], capacity: int):\n    \"\"\"0-1 knapsack problem. Just return the max value.\"\"\"\n    # Each index is a sub-capacity and each value the best value for that sub-capacity so far.\n    best_values = [0] * (capacity + 1)\n    for weight, value in zip(weights, values):\n        # Iterate backwards so we don't take things twice. Forwards would be the unbounded version of the problem.\n        for sub_capacity in range(capacity, 0, -1):\n            if weight <= sub_capacity:\n                # These three lines can be refactored to one, or a slightly more efficient if instead of max.\n                take_value = value + best_values[sub_capacity - weight]",
        "detail": ".gitbook.assets.knapsack_simple",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": ".gitbook.assets.partition",
        "description": ".gitbook.assets.partition",
        "peekOfCode": "def partition(seq: Sequence[T]) -> tuple[list[T], T, list[T]]:\n    \"\"\"Split sequence into a tuple of lesser or equal values, first value, greater values.\"\"\"\n    pivot, *rest = seq\n    low = [n for n in rest if n <= pivot]\n    high = [n for n in rest if n > pivot]\n    return low, pivot, high",
        "detail": ".gitbook.assets.partition",
        "documentation": {}
    },
    {
        "label": "prims",
        "kind": 2,
        "importPath": ".gitbook.assets.prims",
        "description": ".gitbook.assets.prims",
        "peekOfCode": "def prims(graph: Mapping[Node, Mapping[Node, int]], start: Node) -> dict[Node, Optional[Node]]:\n    \"\"\"Find the minimum spanning tree of an undirected, weighted graph.\"\"\"\n    parents = {}\n    to_visit = [(0, None, start)]\n    while to_visit:\n        weight, parent, node = heappop(to_visit)\n        if node in parents:\n            continue\n        parents[node] = parent\n        for next_node, weight in graph[node].items():",
        "detail": ".gitbook.assets.prims",
        "documentation": {}
    },
    {
        "label": "quickselect",
        "kind": 2,
        "importPath": ".gitbook.assets.quickselect",
        "description": ".gitbook.assets.quickselect",
        "peekOfCode": "def quickselect(seq: Sequence[T], k: int) -> T:\n    \"\"\"Find the kth smallest item in a sequence.\"\"\"\n    low, pivot, high = partition(seq)\n    low_len = len(low)\n    if low_len == k:\n        return pivot\n    elif low_len < k:\n        return quickselect(high, k - low_len - 1)\n    else:\n        return quickselect(low, k)",
        "detail": ".gitbook.assets.quickselect",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": ".gitbook.assets.quicksort (1)",
        "description": ".gitbook.assets.quicksort (1)",
        "peekOfCode": "def quicksort(seq: Sequence[T]) -> list[T]:\n    if len(seq) < 2:\n        return list(seq)\n    low, pivot, high = partition(seq)\n    return quicksort(low) + [pivot] + quicksort(high)",
        "detail": ".gitbook.assets.quicksort (1)",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": ".gitbook.assets.quicksort (2)",
        "description": ".gitbook.assets.quicksort (2)",
        "peekOfCode": "def quicksort(seq: Sequence[T]) -> list[T]:\n    if len(seq) < 2:\n        return list(seq)\n    low, pivot, high = partition(seq)\n    return quicksort(low) + [pivot] + quicksort(high)",
        "detail": ".gitbook.assets.quicksort (2)",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": ".gitbook.assets.quicksort",
        "description": ".gitbook.assets.quicksort",
        "peekOfCode": "def quicksort(seq: Sequence[T]) -> list[T]:\n    if len(seq) < 2:\n        return list(seq)\n    low, pivot, high = partition(seq)\n    return quicksort(low) + [pivot] + quicksort(high)",
        "detail": ".gitbook.assets.quicksort",
        "documentation": {}
    },
    {
        "label": "selection_sort_iter",
        "kind": 2,
        "importPath": ".gitbook.assets.selection_sort_iter (1)",
        "description": ".gitbook.assets.selection_sort_iter (1)",
        "peekOfCode": "def selection_sort_iter(seq: MutableSequence[T]) -> None:\n    \"\"\"Use selection sort iteratively on a list in-place.\"\"\"\n    for i, val in enumerate(seq):\n        min_val = min(seq[i:])\n        min_val_i = seq.index(min_val, i)  # First index of min_val at or after i\n        seq[i] = min_val\n        seq[min_val_i] = val",
        "detail": ".gitbook.assets.selection_sort_iter (1)",
        "documentation": {}
    },
    {
        "label": "selection_sort_iter",
        "kind": 2,
        "importPath": ".gitbook.assets.selection_sort_iter",
        "description": ".gitbook.assets.selection_sort_iter",
        "peekOfCode": "def selection_sort_iter(seq: MutableSequence[T]) -> None:\n    \"\"\"Use selection sort iteratively on a list in-place.\"\"\"\n    for i, val in enumerate(seq):\n        min_val = min(seq[i:])\n        min_val_i = seq.index(min_val, i)  # First index of min_val at or after i\n        seq[i] = min_val\n        seq[min_val_i] = val",
        "detail": ".gitbook.assets.selection_sort_iter",
        "documentation": {}
    },
    {
        "label": "selection_sort_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.selection_sort_recur (1)",
        "description": ".gitbook.assets.selection_sort_recur (1)",
        "peekOfCode": "def selection_sort_recur(seq: MutableSequence[T], i=0) -> None:\n    \"\"\"Use selection sort recursively on a list in-place.\"\"\"\n    if i >= len(seq) - 1:\n        return\n    min_val = min(seq[i:])\n    min_val_i = seq.index(min_val, i)\n    seq[min_val_i] = seq[i]\n    seq[i] = min_val\n    selection_sort_recur(seq, i + 1)",
        "detail": ".gitbook.assets.selection_sort_recur (1)",
        "documentation": {}
    },
    {
        "label": "selection_sort_recur",
        "kind": 2,
        "importPath": ".gitbook.assets.selection_sort_recur",
        "description": ".gitbook.assets.selection_sort_recur",
        "peekOfCode": "def selection_sort_recur(seq: MutableSequence[T], i=0) -> None:\n    \"\"\"Use selection sort recursively on a list in-place.\"\"\"\n    if i >= len(seq) - 1:\n        return\n    min_val = min(seq[i:])\n    min_val_i = seq.index(min_val, i)\n    seq[min_val_i] = seq[i]\n    seq[i] = min_val\n    selection_sort_recur(seq, i + 1)",
        "detail": ".gitbook.assets.selection_sort_recur",
        "documentation": {}
    },
    {
        "label": "TestEmployees",
        "kind": 6,
        "importPath": ".gitbook.assets.tests (1)",
        "description": ".gitbook.assets.tests (1)",
        "peekOfCode": "class TestEmployees(TestCase):\n    def setUp(self):\n        agent = Job('Agent', 40000)\n        manager = Job('Manager', 50000)\n        self.alice = Employee('Alice', 'Anaheim', manager)\n        self.bob = Employee('Bob', 'Bodega', agent)\n        self.cindy = Employee('Cindy', 'Camille', agent)\n        self.dan = Employee('Dan', 'Dirk', manager)\n        self.employee_list = [self.dan, self.cindy, self.bob, self.alice]\n    def test_equal(self):",
        "detail": ".gitbook.assets.tests (1)",
        "documentation": {}
    },
    {
        "label": "TestJobs",
        "kind": 6,
        "importPath": ".gitbook.assets.tests (1)",
        "description": ".gitbook.assets.tests (1)",
        "peekOfCode": "class TestJobs(TestCase):\n    def test_str(self):\n        job_title = 'Agent'\n        job = Job(job_title, 40000)\n        self.assertEqual(str(job), job_title)",
        "detail": ".gitbook.assets.tests (1)",
        "documentation": {}
    },
    {
        "label": "TestEmployees",
        "kind": 6,
        "importPath": ".gitbook.assets.tests",
        "description": ".gitbook.assets.tests",
        "peekOfCode": "class TestEmployees(TestCase):\n    def setUp(self):\n        agent = Job('Agent', 40000)\n        manager = Job('Manager', 50000)\n        self.alice = Employee('Alice', 'Anaheim', manager)\n        self.bob = Employee('Bob', 'Bodega', agent)\n        self.cindy = Employee('Cindy', 'Camille', agent)\n        self.dan = Employee('Dan', 'Dirk', manager)\n        self.employee_list = [self.dan, self.cindy, self.bob, self.alice]\n    def test_equal(self):",
        "detail": ".gitbook.assets.tests",
        "documentation": {}
    },
    {
        "label": "TestJobs",
        "kind": 6,
        "importPath": ".gitbook.assets.tests",
        "description": ".gitbook.assets.tests",
        "peekOfCode": "class TestJobs(TestCase):\n    def test_str(self):\n        job_title = 'Agent'\n        job = Job(job_title, 40000)\n        self.assertEqual(str(job), job_title)",
        "detail": ".gitbook.assets.tests",
        "documentation": {}
    },
    {
        "label": "topo_sort_count",
        "kind": 2,
        "importPath": ".gitbook.assets.topo_sort_count",
        "description": ".gitbook.assets.topo_sort_count",
        "peekOfCode": "def topo_sort_count(graph: Mapping[Node, Iterable]) -> Iterable[Node]:\n    \"\"\"Find a topological sorting of a graph by counting in-degrees.\"\"\"\n    in_degrees = Counter(chain(*graph.values()))\n    zero_in_degrees = [node for node in graph if not in_degrees[node]]\n    while zero_in_degrees:\n        node = zero_in_degrees.pop()\n        yield node\n        for next_node in graph[node]:\n            in_degrees[next_node] -= 1\n            if not in_degrees[next_node]:",
        "detail": ".gitbook.assets.topo_sort_count",
        "documentation": {}
    },
    {
        "label": "valid_nesting_multi",
        "kind": 2,
        "importPath": ".gitbook.assets.valid_nesting_multi",
        "description": ".gitbook.assets.valid_nesting_multi",
        "peekOfCode": "def valid_nesting_multi(items: Sequence[Node], openers_to_closers: Mapping[Node, Node]) -> bool:\n    \"\"\"The parentheses problem with multiple brackets.\"\"\"\n    openers = openers_to_closers.keys()\n    closers = set(openers_to_closers.values())\n    unmatched_openers = []\n    for item in items:\n        if item in openers:\n            unmatched_openers.append(item)\n        elif item in closers:\n            if not unmatched_openers:",
        "detail": ".gitbook.assets.valid_nesting_multi",
        "documentation": {}
    }
]